/*
 * DAWN Satellite - SPI Display Support (Framebuffer)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "display.h"

#include <fcntl.h>
#include <linux/fb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>

/* Shared logging (same format as daemon) */
#include "logging.h"

/* Simple 8x8 font data (ASCII 32-127) */
static const uint8_t font_8x8[][8] = {
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* Space */
   { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00 }, /* ! */
   { 0x36, 0x36, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* " */
   { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00 }, /* # */
   { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00 }, /* $ */
   { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00 }, /* % */
   { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00 }, /* & */
   { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* ' */
   { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00 }, /* ( */
   { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00 }, /* ) */
   { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00 }, /* * */
   { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00 }, /* + */
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06 }, /* , */
   { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00 }, /* - */
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00 }, /* . */
   { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00 }, /* / */
   { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00 }, /* 0 */
   { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00 }, /* 1 */
   { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00 }, /* 2 */
   { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00 }, /* 3 */
   { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00 }, /* 4 */
   { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00 }, /* 5 */
   { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00 }, /* 6 */
   { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00 }, /* 7 */
   { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00 }, /* 8 */
   { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00 }, /* 9 */
   { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00 }, /* : */
   { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06 }, /* ; */
   { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00 }, /* < */
   { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00 }, /* = */
   { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00 }, /* > */
   { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00 }, /* ? */
   { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00 }, /* @ */
   { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00 }, /* A */
   { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00 }, /* B */
   { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00 }, /* C */
   { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00 }, /* D */
   { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00 }, /* E */
   { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00 }, /* F */
   { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00 }, /* G */
   { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00 }, /* H */
   { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 }, /* I */
   { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00 }, /* J */
   { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00 }, /* K */
   { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00 }, /* L */
   { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00 }, /* M */
   { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00 }, /* N */
   { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00 }, /* O */
   { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00 }, /* P */
   { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00 }, /* Q */
   { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00 }, /* R */
   { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00 }, /* S */
   { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 }, /* T */
   { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00 }, /* U */
   { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00 }, /* V */
   { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00 }, /* W */
   { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00 }, /* X */
   { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00 }, /* Y */
   { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00 }, /* Z */
   { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00 }, /* [ */
   { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00 }, /* \ */
   { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00 }, /* ] */
   { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00 }, /* ^ */
   { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF }, /* _ */
   { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* ` */
   { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00 }, /* a */
   { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00 }, /* b */
   { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00 }, /* c */
   { 0x38, 0x30, 0x30, 0x3E, 0x33, 0x33, 0x6E, 0x00 }, /* d */
   { 0x00, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00 }, /* e */
   { 0x1C, 0x36, 0x06, 0x0F, 0x06, 0x06, 0x0F, 0x00 }, /* f */
   { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F }, /* g */
   { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00 }, /* h */
   { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 }, /* i */
   { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E }, /* j */
   { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00 }, /* k */
   { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 }, /* l */
   { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00 }, /* m */
   { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00 }, /* n */
   { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00 }, /* o */
   { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F }, /* p */
   { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78 }, /* q */
   { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00 }, /* r */
   { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00 }, /* s */
   { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00 }, /* t */
   { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00 }, /* u */
   { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00 }, /* v */
   { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00 }, /* w */
   { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00 }, /* x */
   { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F }, /* y */
   { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00 }, /* z */
   { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00 }, /* { */
   { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00 }, /* | */
   { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00 }, /* } */
   { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, /* ~ */
};

int display_init(display_t *ctx, const char *fb_device) {
   if (!ctx)
      return -1;

   memset(ctx, 0, sizeof(display_t));

   const char *dev = fb_device ? fb_device : DISPLAY_DEFAULT_FB;

   /* Open framebuffer device */
   ctx->fd = open(dev, O_RDWR);
   if (ctx->fd < 0) {
      LOG_ERROR("Cannot open framebuffer '%s': %m", dev);
      return -1;
   }

   /* Get fixed screen info */
   struct fb_fix_screeninfo finfo;
   if (ioctl(ctx->fd, FBIOGET_FSCREENINFO, &finfo) < 0) {
      LOG_ERROR("Cannot get fixed screen info: %m");
      close(ctx->fd);
      return -1;
   }

   /* Get variable screen info */
   struct fb_var_screeninfo vinfo;
   if (ioctl(ctx->fd, FBIOGET_VSCREENINFO, &vinfo) < 0) {
      LOG_ERROR("Cannot get variable screen info: %m");
      close(ctx->fd);
      return -1;
   }

   ctx->width = vinfo.xres;
   ctx->height = vinfo.yres;
   ctx->line_length = finfo.line_length;
   ctx->fb_size = finfo.smem_len;

   /* Map framebuffer to memory */
   ctx->framebuffer = (uint16_t *)mmap(NULL, ctx->fb_size, PROT_READ | PROT_WRITE, MAP_SHARED,
                                       ctx->fd, 0);
   if (ctx->framebuffer == MAP_FAILED) {
      LOG_ERROR("Cannot mmap framebuffer: %m");
      close(ctx->fd);
      return -1;
   }

   ctx->initialized = 1;

   LOG_INFO("Display initialized: %s (%ux%u, %u bpp)", dev, ctx->width, ctx->height,
            vinfo.bits_per_pixel);

   /* Clear to black */
   display_clear(ctx, COLOR_BLACK);

   return 0;
}

void display_cleanup(display_t *ctx) {
   if (ctx) {
      if (ctx->framebuffer && ctx->framebuffer != MAP_FAILED) {
         munmap(ctx->framebuffer, ctx->fb_size);
      }
      if (ctx->fd >= 0) {
         close(ctx->fd);
      }
      ctx->initialized = 0;
      LOG_INFO("Display cleaned up");
   }
}

void display_clear(display_t *ctx, uint16_t color) {
   if (!ctx || !ctx->initialized)
      return;

   for (uint32_t y = 0; y < ctx->height; y++) {
      uint16_t *row = (uint16_t *)((uint8_t *)ctx->framebuffer + y * ctx->line_length);
      for (uint32_t x = 0; x < ctx->width; x++) {
         row[x] = color;
      }
   }
}

void display_pixel(display_t *ctx, int x, int y, uint16_t color) {
   if (!ctx || !ctx->initialized)
      return;
   if (x < 0 || x >= (int)ctx->width || y < 0 || y >= (int)ctx->height)
      return;

   uint16_t *row = (uint16_t *)((uint8_t *)ctx->framebuffer + y * ctx->line_length);
   row[x] = color;
}

void display_fill_rect(display_t *ctx, int x, int y, int w, int h, uint16_t color) {
   if (!ctx || !ctx->initialized)
      return;

   /* Clip to screen bounds */
   if (x < 0) {
      w += x;
      x = 0;
   }
   if (y < 0) {
      h += y;
      y = 0;
   }
   if (x + w > (int)ctx->width)
      w = ctx->width - x;
   if (y + h > (int)ctx->height)
      h = ctx->height - y;
   if (w <= 0 || h <= 0)
      return;

   for (int row = y; row < y + h; row++) {
      uint16_t *ptr = (uint16_t *)((uint8_t *)ctx->framebuffer + row * ctx->line_length) + x;
      for (int col = 0; col < w; col++) {
         ptr[col] = color;
      }
   }
}

void display_hline(display_t *ctx, int x, int y, int w, uint16_t color) {
   display_fill_rect(ctx, x, y, w, 1, color);
}

void display_vline(display_t *ctx, int x, int y, int h, uint16_t color) {
   display_fill_rect(ctx, x, y, 1, h, color);
}

void display_text(display_t *ctx,
                  int x,
                  int y,
                  const char *text,
                  uint16_t color,
                  uint16_t bg,
                  int scale) {
   if (!ctx || !ctx->initialized || !text)
      return;
   if (scale < 1)
      scale = 1;

   int cursor_x = x;
   int cursor_y = y;

   while (*text) {
      char c = *text++;

      /* Handle newline */
      if (c == '\n') {
         cursor_x = x;
         cursor_y += 8 * scale;
         continue;
      }

      /* Get font data (map ASCII to font array) */
      int font_idx = c - 32;
      if (font_idx < 0 || font_idx >= 95)
         font_idx = 0; /* Default to space */

      const uint8_t *glyph = font_8x8[font_idx];

      /* Draw character */
      for (int row = 0; row < 8; row++) {
         uint8_t bits = glyph[row];
         for (int col = 0; col < 8; col++) {
            uint16_t pixel_color = (bits & (1 << (7 - col))) ? color : bg;
            /* Scale the pixel */
            for (int sy = 0; sy < scale; sy++) {
               for (int sx = 0; sx < scale; sx++) {
                  display_pixel(ctx, cursor_x + col * scale + sx, cursor_y + row * scale + sy,
                                pixel_color);
               }
            }
         }
      }

      cursor_x += 8 * scale;
   }
}

void display_progress_bar(display_t *ctx,
                          int x,
                          int y,
                          int w,
                          int h,
                          int percent,
                          uint16_t fg,
                          uint16_t bg) {
   if (!ctx || !ctx->initialized)
      return;

   if (percent < 0)
      percent = 0;
   if (percent > 100)
      percent = 100;

   /* Draw background */
   display_fill_rect(ctx, x, y, w, h, bg);

   /* Draw filled portion */
   int fill_w = (w * percent) / 100;
   if (fill_w > 0) {
      display_fill_rect(ctx, x, y, fill_w, h, fg);
   }
}

void display_fill_circle(display_t *ctx, int cx, int cy, int r, uint16_t color) {
   if (!ctx || !ctx->initialized)
      return;

   for (int y = -r; y <= r; y++) {
      for (int x = -r; x <= r; x++) {
         if (x * x + y * y <= r * r) {
            display_pixel(ctx, cx + x, cy + y, color);
         }
      }
   }
}
